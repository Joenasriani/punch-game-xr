<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STRESS BUSTER 3000 - WebXR Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Anton&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        .title-font { font-family: 'Anton', sans-serif; letter-spacing: 0.1em; }
        
        /* The main entry screen */
        #ui-overlay { 
            position: absolute; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            display: flex; flex-direction: column; 
            align-items: center; justify-content: center; 
            background: linear-gradient(135deg, #4f46e5 0%, #1e1b4b 100%); 
            z-index: 20; 
            color: white;
            transition: opacity 0.5s; 
        }

        /* The in-game target selector (visible in AR) */
        #ar-menu {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            border-radius: 50px;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        #ar-menu.active { opacity: 1; pointer-events: all; }

        .thumb { 
            width: 60px; height: 60px; 
            border-radius: 50%; 
            border: 2px solid white; 
            cursor: pointer; 
            transition: all 0.2s; 
            object-fit: cover; 
        }
        .thumb:hover { transform: scale(1.1); }
        .thumb.active { border-color: #ef4444; box-shadow: 0 0 15px #ef4444; }
        
        #xr-button-container button { 
            padding: 1.5rem 3rem !important; 
            font-size: 1.25rem !important;
            font-weight: 800 !important; 
            border-radius: 9999px !important; 
            background: #ffffff !important; 
            color: #4f46e5 !important; 
            border: none !important; 
            cursor: pointer; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            text-transform: uppercase;
        }
    </style>
</head>
<body>

    <!-- Main Entry Screen -->
    <div id="ui-overlay">
        <div class="text-center mb-10">
            <h1 class="text-7xl font-black text-white uppercase title-font">STRESS BUSTER</h1>
            <p class="text-indigo-200 text-sm font-bold uppercase tracking-[0.5em] mt-2">Physical Punching Sim</p>
        </div>

        <div id="xr-button-container" class="mb-12"></div>
        
        <div class="max-w-xs text-center text-indigo-100 text-xs opacity-80">
            Open your camera to begin. You can switch targets once you are inside the simulation.
        </div>
    </div>

    <!-- In-AR Target Menu -->
    <div id="ar-menu">
        <!-- Populated by JS -->
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.160.0';
        import { ARButton } from 'https://cdn.skypack.dev/three@0.160.0/examples/jsm/webxr/ARButton.js';

        const PEOPLE = [
            { name: "TRUMP", url: "https://upload.wikimedia.org/wikipedia/commons/5/56/Donald_Trump_official_portrait.jpg" },
            { name: "ELON", url: "https://upload.wikimedia.org/wikipedia/commons/3/34/Elon_Musk_Royal_Society_%28crop2%29.jpg" },
            { name: "ZUCK", url: "https://upload.wikimedia.org/wikipedia/commons/1/18/Mark_Zuckerberg_F8_2019_Keynote_%2831119002762%29_%28cropped%29.jpg" }
        ];

        let currentTargetUrl = PEOPLE[0].url;
        let scene, camera, renderer, targetGroup, targetMesh, hand0, hand1;
        let particles = [];
        let audioCtx;
        let lastPunchTime = 0;

        const overlay = document.getElementById('ui-overlay');
        const arMenu = document.getElementById('ar-menu');

        // Setup the AR Menu
        PEOPLE.forEach((p, i) => {
            const img = document.createElement('img');
            img.src = p.url;
            img.className = `thumb ${i === 0 ? 'active' : ''}`;
            img.onclick = () => {
                document.querySelectorAll('.thumb').forEach(t => t.classList.remove('active'));
                img.classList.add('active');
                currentTargetUrl = p.url;
                updateTargetTexture(p.url);
            };
            arMenu.appendChild(img);
        });

        function playPunchSFX() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.frequency.setValueAtTime(140, now);
            osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
            gain.gain.setValueAtTime(0.6, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(now + 0.15);
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Create AR Button with overlay
            const btn = ARButton.createButton(renderer, { 
                requiredFeatures: ['hand-tracking'],
                optionalFeatures: ['dom-overlay'],
                domOverlay: { root: document.body }
            });
            document.getElementById('xr-button-container').appendChild(btn);

            scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 2));

            targetGroup = new THREE.Group();
            const geometry = new THREE.CircleGeometry(0.18, 32);
            const material = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide });
            targetMesh = new THREE.Mesh(geometry, material);
            targetGroup.add(targetMesh);
            targetGroup.position.set(0, 1.4, -0.6); 
            scene.add(targetGroup);

            updateTargetTexture(currentTargetUrl);

            hand0 = renderer.xr.getHand(0);
            hand1 = renderer.xr.getHand(1);
            scene.add(hand0);
            scene.add(hand1);

            renderer.setAnimationLoop(render);
        }

        function updateTargetTexture(url) {
            new THREE.TextureLoader().load(url, (tex) => {
                targetMesh.material.map = tex;
                targetMesh.material.needsUpdate = true;
            });
        }

        function spawnBlood(pos) {
            for (let i = 0; i < 15; i++) {
                const p = new THREE.Mesh(
                    new THREE.SphereGeometry(0.007),
                    new THREE.MeshBasicMaterial({ color: 0xaa0000 })
                );
                p.position.copy(pos);
                p.userData = {
                    vel: new THREE.Vector3((Math.random()-0.5)*0.08, Math.random()*0.08, (Math.random()-0.5)*0.08),
                    life: 1.0
                };
                scene.add(p);
                particles.push(p);
            }
        }

        function checkImpact(hand) {
            if (!hand.visible) return;
            const joint = hand.joints['index-finger-tip'] || hand.joints['middle-finger-tip'];
            if (!joint) return;

            const distance = joint.position.distanceTo(targetGroup.position);
            const now = Date.now();

            if (distance < 0.12 && now - lastPunchTime > 250) {
                lastPunchTime = now;
                playPunchSFX();
                spawnBlood(targetGroup.position);
                targetGroup.scale.set(1.3, 1.3, 1.3);
                setTimeout(() => targetGroup.scale.set(1, 1, 1), 80);
            }
        }

        function render() {
            if (renderer.xr.isPresenting) {
                overlay.style.opacity = '0';
                overlay.style.pointerEvents = 'none';
                arMenu.classList.add('active');
                targetGroup.lookAt(camera.position); 
            } else {
                overlay.style.opacity = '1';
                overlay.style.pointerEvents = 'all';
                arMenu.classList.remove('active');
            }

            checkImpact(hand0);
            checkImpact(hand1);

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.vel);
                p.userData.vel.y -= 0.0025; 
                p.userData.life -= 0.025;
                p.scale.setScalar(p.userData.life);
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.onload = init;
    </script>
</body>
</html>

            osc.frequency.setValueAtTime(140, now);
            osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
            gain.gain.setValueAtTime(0.6, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(now + 0.15);
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            const btn = ARButton.createButton(renderer, { 
                requiredFeatures: ['hand-tracking'],
                optionalFeatures: ['dom-overlay'],
                domOverlay: { root: overlay }
            });
            document.getElementById('xr-button-container').appendChild(btn);

            scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1.5));

            targetGroup = new THREE.Group();
            const geometry = new THREE.CircleGeometry(0.18, 32);
            const material = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide });
            targetMesh = new THREE.Mesh(geometry, material);
            targetGroup.add(targetMesh);
            targetGroup.position.set(0, 1.4, -0.6); 
            scene.add(targetGroup);

            updateTargetTexture(currentTargetUrl);

            hand0 = renderer.xr.getHand(0);
            hand1 = renderer.xr.getHand(1);
            scene.add(hand0);
            scene.add(hand1);

            const handMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.3 });
            [hand0, hand1].forEach(h => {
                const dot = new THREE.Mesh(new THREE.SphereGeometry(0.02), handMat);
                h.add(dot);
            });

            renderer.setAnimationLoop(render);

            // Trigger notification immediately on start
            setTimeout(() => {
                autoPrompt.classList.add('show');
            }, 1000);
        }

        function updateTargetTexture(url) {
            new THREE.TextureLoader().load(url, (tex) => {
                targetMesh.material.map = tex;
                targetMesh.material.needsUpdate = true;
            });
        }

        function spawnBlood(pos) {
            for (let i = 0; i < 15; i++) {
                const p = new THREE.Mesh(
                    new THREE.SphereGeometry(0.007),
                    new THREE.MeshBasicMaterial({ color: 0xaa0000 })
                );
                p.position.copy(pos);
                p.userData = {
                    vel: new THREE.Vector3((Math.random()-0.5)*0.07, Math.random()*0.07, (Math.random()-0.5)*0.07),
                    life: 1.0
                };
                scene.add(p);
                particles.push(p);
            }
        }

        function checkImpact(hand) {
            if (!hand.visible) return;
            const joint = hand.joints['index-finger-tip'] || hand.joints['middle-finger-tip'];
            if (!joint) return;

            const distance = joint.position.distanceTo(targetGroup.position);
            const now = Date.now();

            if (distance < 0.12 && now - lastPunchTime > 250) {
                lastPunchTime = now;
                playPunchSFX();
                spawnBlood(targetGroup.position);
                
                targetGroup.scale.set(1.3, 1.3, 1.3);
                setTimeout(() => targetGroup.scale.set(1, 1, 1), 80);
            }
        }

        function render() {
            if (renderer.xr.isPresenting) {
                overlay.style.opacity = '0';
                overlay.style.pointerEvents = 'none';
                autoPrompt.classList.remove('show');
                targetGroup.lookAt(camera.position); 
            } else {
                overlay.style.opacity = '1';
                overlay.style.pointerEvents = 'all';
            }

            checkImpact(hand0);
            checkImpact(hand1);

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.vel);
                p.userData.vel.y -= 0.0025; 
                p.userData.life -= 0.025;
                p.scale.setScalar(p.userData.life);
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.onload = init;
    </script>
</body>
</html>

            targetGroup.add(targetMesh);
            targetGroup.position.set(0, 1.4, -0.6); 
            scene.add(targetGroup);

            updateTargetTexture(currentTargetUrl);

            hand0 = renderer.xr.getHand(0);
            hand1 = renderer.xr.getHand(1);
            scene.add(hand0);
            scene.add(hand1);

            const handMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.3 });
            [hand0, hand1].forEach(h => {
                const dot = new THREE.Mesh(new THREE.SphereGeometry(0.02), handMat);
                h.add(dot);
            });

            renderer.setAnimationLoop(render);
        }

        function updateTargetTexture(url) {
            new THREE.TextureLoader().load(url, (tex) => {
                targetMesh.material.map = tex;
                targetMesh.material.needsUpdate = true;
            });
        }

        function spawnBlood(pos) {
            for (let i = 0; i < 12; i++) {
                const p = new THREE.Mesh(
                    new THREE.SphereGeometry(0.006),
                    new THREE.MeshBasicMaterial({ color: 0xaa0000 })
                );
                p.position.copy(pos);
                p.userData = {
                    vel: new THREE.Vector3((Math.random()-0.5)*0.06, Math.random()*0.06, (Math.random()-0.5)*0.06),
                    life: 1.0
                };
                scene.add(p);
                particles.push(p);
            }
        }

        function checkImpact(hand) {
            if (!hand.visible) return;
            const joint = hand.joints['index-finger-tip'] || hand.joints['middle-finger-tip'];
            if (!joint) return;

            const distance = joint.position.distanceTo(targetGroup.position);
            const now = Date.now();

            if (distance < 0.12 && now - lastPunchTime > 250) {
                lastPunchTime = now;
                playPunchSFX();
                spawnBlood(targetGroup.position);
                
                targetGroup.scale.set(1.3, 1.3, 1.3);
                setTimeout(() => targetGroup.scale.set(1, 1, 1), 80);
            }
        }

        function render() {
            if (renderer.xr.isPresenting) {
                overlay.style.opacity = '0';
                overlay.style.pointerEvents = 'none';
                targetGroup.lookAt(camera.position); 
            } else {
                overlay.style.opacity = '1';
                overlay.style.pointerEvents = 'all';
            }

            checkImpact(hand0);
            checkImpact(hand1);

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.vel);
                p.userData.vel.y -= 0.0025; 
                p.userData.life -= 0.025;
                p.scale.setScalar(p.userData.life);
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>


